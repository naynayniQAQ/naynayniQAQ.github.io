<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发编程</title>
      <link href="/2023/08/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/08/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ol><li>NEW 创建</li><li>RUNNABLE 运行</li><li>WAITING 等待</li><li>TIMED_WAITING 超时等待</li><li>BLOCKED 阻塞</li><li>TERMINATED 结束</li></ol><h3 id="线程状态装换"><a href="#线程状态装换" class="headerlink" title="线程状态装换"></a>线程状态装换</h3><p><img src="https://github.com/Tommmmmmmmmm/pic/blob/main/ThreadStatus.jpg?raw=true"></p><h3 id="如何优雅的停止一个线程"><a href="#如何优雅的停止一个线程" class="headerlink" title="如何优雅的停止一个线程"></a>如何优雅的停止一个线程</h3><ol><li>stop()：已经废弃</li><li>interrupt()：中断信号</li><li>volatile关键字：保证标志在多线程的可见性</li></ol><h3 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h3><h3 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h3><ol><li>Synchronized是Java关键字，Lock是一个接口；</li><li>Sychronized会自动释放锁，不能设置超时时间。而Lock需要手动释放锁，可以设置超时时间；</li><li>S是非公平锁，Lock默认是非公平锁，但是可以选择公平锁；</li></ol><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="为什么要有ThreadLocal？"><a href="#为什么要有ThreadLocal？" class="headerlink" title="为什么要有ThreadLocal？"></a>为什么要有ThreadLocal？</h3><p>单个线程独占共享资源。</p><h3 id="它解决了什么？"><a href="#它解决了什么？" class="headerlink" title="它解决了什么？"></a>它解决了什么？</h3><p>多线程中的每个线程的共享资源保证线程安全，互不影响。</p><h3 id="怎么解决的？"><a href="#怎么解决的？" class="headerlink" title="怎么解决的？"></a>怎么解决的？</h3><p>set方法对初始值进行更改，get获取值，remove删除。在ThreadLocal中有个一个ThreadLocalMap，key就是ThreadLocal对象，value就是它的值。就是把共享资源作为一个副本保存在map中，并且是线程私有的。</p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>底层用弱引用，GC会回收。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinle</title>
      <link href="/2023/08/30/Sentinel/"/>
      <url>/2023/08/30/Sentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="一、雪崩问题"><a href="#一、雪崩问题" class="headerlink" title="一、雪崩问题"></a>一、雪崩问题</h1><blockquote><p>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</p><p>解决雪崩的方案：</p><ol><li>超时处理：设定超时时间。请求超过一定时间没有响应就返回错误信息，不会无休止等待</li><li>舱壁模式：限定每个业务能使用的线程数，避免好近整个tomcat的资源。线程隔离</li><li>熔断降级：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。</li><li>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。Sentinel。（预防，前面三种是出现异常之后的策略）</li></ol></blockquote><h1 id="二、服务保护技术"><a href="#二、服务保护技术" class="headerlink" title="二、服务保护技术"></a>二、服务保护技术</h1><blockquote><ol><li>Sentinel</li><li>Hystrix</li></ol></blockquote><h1 id="三、Sentinel"><a href="#三、Sentinel" class="headerlink" title="三、Sentinel"></a>三、Sentinel</h1><blockquote><ol><li><p>流控模式</p><p>1.1 直接</p><p>1.2 关联</p><p>1.3 链路</p></li><li><p>流控效果</p><p>2.1 快速失败</p><p>2.2 预热模式</p><p>2.3 排队等待</p></li><li><p>热点参数限流 （统计参数值相同的请求是否超过阈值）</p><p>3.1 只对注解@SentinelResource(“hot”)有效，对springmvc无效</p></li></ol></blockquote><h1 id="四、隔离和降级"><a href="#四、隔离和降级" class="headerlink" title="四、隔离和降级"></a>四、隔离和降级</h1><h1 id="五、分布式事务-seata"><a href="#五、分布式事务-seata" class="headerlink" title="五、分布式事务-seata"></a>五、分布式事务-seata</h1><ol><li><p>理论基础</p><blockquote><ul><li>1.1 CAP定理<ul><li>Consistency（一致性）：用户访问分布式系统的任意节点，得到的数据必须一致。</li><li>Availability（可用性）：用户访问集群中的健康节点，必须得到响应。</li><li>Partition（分区）：分区一定会出现。</li><li>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务。</li></ul></li><li>1.2 BASE理论<ul><li>Basically Avaliable（基本可用）：分布式系统出现故障时，允许损失部分可用性，即保证核心可用。</li><li>Soft State（软状态）：在一定的时间内，允许出现中间状态，比如临时的状态不一致。</li><li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul></li><li>1.3 分布式事务最大的问题就是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：<ul><li>AP：允许出现数据短暂的不一致</li><li>CP：数据一致后，一起返回</li></ul></li></ul></blockquote></li><li><p>Seata框架</p><blockquote><p>开源的分布式事务解决框架。</p><ul><li>TC-事务协调者：</li><li>TM-事务管理器：</li><li>RM-资源管理器：</li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识IoC</title>
      <link href="/2023/02/25/IoC/"/>
      <url>/2023/02/25/IoC/</url>
      
        <content type="html"><![CDATA[<h1 id="IoC是什么？"><a href="#IoC是什么？" class="headerlink" title="IoC是什么？"></a>IoC是什么？</h1><blockquote><p>IOC：Inversion of Control，控制反转。借助于“第三方”实现具有依赖关系的对象之间的解耦，这里的第三方方就是IoC容器。如何实现控制反转？就是在IoC容器运行期间，动态地将某种依赖关系注入到对象之中。就是依赖注入DI（Dependency Injection）。IoC和DI在不同的角度去描述，实际上指的事情是一样的。在Java中实现这一理念用的反射。</p></blockquote><h1 id="Java中如何实现SpringIoC？"><a href="#Java中如何实现SpringIoC？" class="headerlink" title="Java中如何实现SpringIoC？"></a>Java中如何实现SpringIoC？</h1><ol><li><p>在POM文件中引入依赖，spring-context。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>我的Jdk版本是1.8，在引入spring-context时选择最新版本6.0.4后，程序启动会报错。</p><p>&#x2F;Users&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;qyy&#x2F;springIoc&#x2F;ApplicationSpringTest.java:4:35<br>java: 无法访问org.springframework.context.ApplicationContext<br>  错误的类文件: &#x2F;Users&#x2F;program&#x2F;mavenku&#x2F;org&#x2F;springframework&#x2F;spring-context&#x2F;6.0.4&#x2F;spring-context-6.0.4.jar!&#x2F;org&#x2F;springframework&#x2F;context&#x2F;ApplicationContext.class<br>    类文件具有错误的版本 61.0, 应为 52.0<br>    请删除该文件或确保该文件位于正确的类路径子目录中。</p><p>将依赖版本改为5.2.6.RELEASE后，程序正常运行。</p></blockquote></li><li><p>定义实体类Person和Apple，包括无参构造函数。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String origin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrigin</span><span class="params">(String origin)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.origin = origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Apple apple;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Apple <span class="title function_">getApple</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApple</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.apple = apple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, apple=&quot;</span> + apple +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>在resources目录下添加applicationContext.xml文件。文件头需要spring的约束，然后就可以在bean标签中设置id以及实体类的位置，对对象属性赋值。</p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sweetApple&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.qyy.springIoc.Apple&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;红色&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">value</span>=<span class="string">&quot;红富士&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;origin&quot;</span> <span class="attr">value</span>=<span class="string">&quot;欧洲&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.qyy.springIoc.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;apple&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sweetApple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>获取bean容器中的对象。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationSpringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;person&quot;</span>,Person.class);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>通过上述方式可以看到，我们没有使用new关键字，却可以创建出Apple对象，这就是控制反转。把创建对象的主动权交给IoC，在容器运行期间将依赖关系注入到对象中。输出结果：Person{name&#x3D;’Tom’, apple&#x3D;Apple{title&#x3D;’红富士’, color&#x3D;’红色’, origin&#x3D;’欧洲’}}</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>About Thread</title>
      <link href="/2023/01/03/20230103Thread/"/>
      <url>/2023/01/03/20230103Thread/</url>
      
        <content type="html"><![CDATA[<h1 id="线程是什么？"><a href="#线程是什么？" class="headerlink" title="线程是什么？"></a>线程是什么？</h1><blockquote><p>线程就是进程中的一个任务，一个进程可以有多个线程，但是一个线程只能存在在一个进程中。<br>并行：多个线程一起执行，多核CPU同时处理多个线程。<br>并发：多个线程交替运行。单核CPU的时间片交替分配给多个线程，时间是纳秒级别的，因此宏观上看是同时进行的。</p></blockquote><h1 id="Java创建线程-一个继承，两个实现"><a href="#Java创建线程-一个继承，两个实现" class="headerlink" title="Java创建线程(一个继承，两个实现)"></a>Java创建线程(一个继承，两个实现)</h1><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">      task.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">    Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么重写了run方法，但是启动线程时却调用了start方法"><a href="#为什么重写了run方法，但是启动线程时却调用了start方法" class="headerlink" title="为什么重写了run方法，但是启动线程时却调用了start方法"></a>为什么重写了run方法，但是启动线程时却调用了start方法</h1><p>使用start，由操作系统的线程调度策略来决定。run方法是一般Java的调用：先被调用就会先执行，后被调用就会后执行。</p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><blockquote><p>1.NEW 创建<br>2.RUNNABLE 运行<br>3.BLOCKED 阻塞<br>4.WAITING 等待<br>5.TIMED_WAITING 超时等待<br>6.TERMINATED 终止</p></blockquote><h1 id="线程同步问题，去加锁解决"><a href="#线程同步问题，去加锁解决" class="headerlink" title="线程同步问题，去加锁解决"></a>线程同步问题，去加锁解决</h1><blockquote><p>1.synchronize 代码块</p></blockquote><h1 id="死锁是怎么产生的"><a href="#死锁是怎么产生的" class="headerlink" title="死锁是怎么产生的"></a>死锁是怎么产生的</h1><blockquote><p>由于资源的交叉引用，锁中嵌套锁。</p></blockquote><h1 id="如何防止死锁"><a href="#如何防止死锁" class="headerlink" title="如何防止死锁"></a>如何防止死锁</h1><blockquote><p>1.减少对公共资源的引用<br>2.使用完后立即释放资源<br>3.增加超时机制</p></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><blockquote><p>由于线程是与CPU关联，对内存使用相关。所以如果无线创建线程，就会导致内存溢出。因此引入了线程池。JUC:Java.Util.Concurrent</p></blockquote><h2 id="JUC提供的四种线程池"><a href="#JUC提供的四种线程池" class="headerlink" title="JUC提供的四种线程池"></a>JUC提供的四种线程池</h2><blockquote><p>1.定长线程池：初始化时就设置了池的容量。<br>2.可缓存线程池：最大容量没有限制，空闲的线程会重复利用。<br>3.单一线程池：只有一个线程。<br>4.周期线程池：定时去创建线程，有频率。</p></blockquote><h1 id="ThreadLocal两大用途"><a href="#ThreadLocal两大用途" class="headerlink" title="ThreadLocal两大用途"></a>ThreadLocal两大用途</h1><blockquote><p>工具类多线程安全问题，虽然可以加锁解决，但是加锁对资源占用大。<br>多赋值场景，如：拦截器获取的用户。只需赋值一次。</p></blockquote><h1 id="使用ThreadLocal的优点"><a href="#使用ThreadLocal的优点" class="headerlink" title="使用ThreadLocal的优点"></a>使用ThreadLocal的优点</h1><h1 id="ThreadLocal主要的四个方法"><a href="#ThreadLocal主要的四个方法" class="headerlink" title="ThreadLocal主要的四个方法"></a>ThreadLocal主要的四个方法</h1><blockquote><p>set<br>innitialValue<br>get<br>remove</p></blockquote><h1 id="Thread、ThreadLocal、ThreadLocalMap"><a href="#Thread、ThreadLocal、ThreadLocalMap" class="headerlink" title="Thread、ThreadLocal、ThreadLocalMap"></a>Thread、ThreadLocal、ThreadLocalMap</h1><blockquote><p>每一个线程Thread 都有ThreadLocalMap 每一个ThreadMap有多个ThreadLocal </p></blockquote><h1 id="使用ThreaLocal需要注意的五点"><a href="#使用ThreaLocal需要注意的五点" class="headerlink" title="使用ThreaLocal需要注意的五点"></a>使用ThreaLocal需要注意的五点</h1><blockquote><p>内存泄漏 ThreadLocalMap的Key是弱引用<br>如果可以不适用ThreadLocal就可以解决问题，那就不使用ThreadLocal</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
